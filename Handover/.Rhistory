plot(0, xlim=c(0,1000), ylim=c(0, 15), type="l", xlab="Nt", ylab="fecundity")
for(i in 1:length(b)){
for(j in 1:length(Nt)){
fec<- max_fec*exp(-1*b[i]*Nt[j])
points(Nt[j], fec, col=cols[i], pch=20)
}
}
legend(500,15, legend=c("1/500", "1/400", "1/300",
"1/200", "1/100"), col=cols,
fill=cols, ncol=3, cex=0.8)
300^2
rnorm(20, 0.075, 0.0075)
n_layers=9 #how many layer files do you have?
min_depth=0 #surface=0, otherwise which minimum depth to plot from
dint=10 #depth interval in metres
res=1500 #resolution in metres
min_x=428430 #this is the minimum x coordinate IN METRES!
min_y=6123500 #this is the minimum y coordinate IN METRES!
nr=245 #number of rows
nc=198 #number of columns
max_y=min_y+(res*nr)
max_x=min_x+(res*nc)
min_x
max_x
min_y
max_y
install.packages("data.table")
library(data.table)
library(raster)
library(randomForest)
install.packages("randomForest")
library(randomForest)
library(lattice)
library(RColorBrewer)
library(PresenceAbsence)
install.packages("PresenceAbsence")
library(PresenceAbsence)
(2570.697/100)- 273.15
(2570.697/100)
install.packages("LandscaleR")
install.packages("LandScaleR")
devtools
devtools::install_github("https://github.com/TamsinWoodman/LandScaleR")
library(dismo)
?biovars
###getting ERA5 data
install.packages("ecmwf")
###getting ERA5 data
install.packages("ecmwfr")
library("ecmwfr")
#necessary libraries
library(terra)
#set your working directory
setwd("C:/Users/Rey/Documents/Ischnura/Handover/")
#get presence records
isch_dat <- read.table('data/Ischnura_elegans_2022_10_26.csv', header=T, sep=',')
xy_2000s<- isch_dat[isch_dat$year<=2000,]
xy_2000s<- isch_dat[(isch_dat$year<=2000) &(!is.na(isch_dat$year)),]
View(xy_2000s)
xy_2000s<- isch_dat[(isch_dat$year>=2000) &(!is.na(isch_dat$year)),]
xy_2000s<- isch_dat[(isch_dat$year>=2000) &(!is.na(isch_dat$year)),c(5,4, 10,12)]
############################
#specific year for env variables
years<- sort(unique(xy_2000s$year))
############################
#specific year for env variables
#use fenno_layers as examples
fenno_layers<- rast("data/land_layers_fenno.tif")
y=1
yr_dat<- xy_2000s[xy_2000s$year==years[y],] #get the position data
View(yr_dat)
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(fenno_coast))
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(fenno_layers))
yr_env<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
yr_ext<- terra::extract(yr_env, yr_vect, xy=T, cells=T)[,c(10:12, 2:9)]
yr_ext<- yr_ext[complete.cases(yr_ext), ]
yr_ext<- cbind(occ=rep(1,nrow(yr_ext)), year=rep(years[y],nrow(yr_ext)), yr_ext)
library(sdm)
yr_bg<- sdm::background(yr_env, 100, "gRandom" )#[,-c(1:2)]
yr_bg<- cbind(occ=rep(0,nrow(yr_bg)),year=rep(years[y],nrow(yr_bg)),
cell=cellFromXY(yr_env, as.matrix(cbind(yr_bg$x,yr_bg$y))),yr_bg )
env_ext<- rbind(env_ext, yr_ext)
bg_ext<- rbind(bg_ext, yr_bg)
#env_ext<- rbind(env_ext, yr_bg)
env_ext<-c()
bg_ext<- c()
if(y==1){env_ext<- yr_ext; bg_ext<- yr_bg}
else{
#env_ext<- rbind(env_ext, yr_bg)
env_ext<-c()
bg_ext<- c()
for(y in 1:length(years)){
print(years[y])
yr_dat<- xy_2000s[xy_2000s$year==years[y],] #get the position data
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(fenno_layers))
yr_env<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
yr_ext<- terra::extract(yr_env, yr_vect, xy=T, cells=T)[,c(10:12, 2:9)]
yr_ext<- yr_ext[complete.cases(yr_ext), ]
yr_ext<- cbind(occ=rep(1,nrow(yr_ext)), year=rep(years[y],nrow(yr_ext)), yr_ext)
yr_bg<- sdm::background(yr_env, 100, "gRandom" )#[,-c(1:2)]
yr_bg<- cbind(occ=rep(0,nrow(yr_bg)),year=rep(years[y],nrow(yr_bg)),
cell=cellFromXY(yr_env, as.matrix(cbind(yr_bg$x,yr_bg$y))),yr_bg )
if(y==1){env_ext<- yr_ext; bg_ext<- yr_bg}
else{
env_ext<- rbind(env_ext, yr_ext)
bg_ext<- rbind(bg_ext, yr_bg)
}
rm(yr_env)
gc() #garbage collector
}
#get rid of duplicates
env_ext_dup<- env_ext[!duplicated(env_ext[c('cell')]), ]
library(spThin)
View(env_ext_dup)
# Remove adjacent cells of presence/background data:
occ<- env_ext_dup[,c(4,5,2, 6:13)]
colnames(occ)<- c("x","y", "year", "Temp","Diurnal_range","Temp_wet","Temp_warm","Elevation",
"Land_cover","Perc_water","Dist_coast")
variablenames<- colnames(occ)[-(1:3)]
autocorrelation <- spatiotemp_autocorr(occ,
varname = variablenames,
plot = TRUE,
temporal.level = c("year"))
library(dynamicSDM)
autocorrelation <- spatiotemp_autocorr(occ,
varname = variablenames,
plot = TRUE,
temporal.level = c("year"))
autocorrelation
View(env_ext_dup)
View(env_ext)
#now i need to match the presence points (per year) to the environment of that year
#all variables need to be in a single stack so that you can pass it to extract()
env_ext<-c()
bg_ext<- c()
for(y in 1:length(years)){
print(years[y])
yr_dat<- xy_2000s[xy_2000s$year==years[y],] #get the position data
#turn it into a terra::vect
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(fenno_layers))
#read in that year's environmental/habitat data
yr_env<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
#match coordinates with env data
yr_ext<- terra::extract(yr_env, yr_vect, xy=T, cells=T)[,c(10:12, 2:9)]
#yr_ext<- yr_ext[complete.cases(yr_ext), ]
yr_ext<- cbind(occ=rep(1,nrow(yr_ext)), year=rep(years[y],nrow(yr_ext)), yr_ext)
#get pseudo-absence points
yr_bg<- sdm::background(yr_env, 100, "gRandom" )#[,-c(1:2)]
yr_bg<- cbind(occ=rep(0,nrow(yr_bg)),year=rep(years[y],nrow(yr_bg)),
cell=cellFromXY(yr_env, as.matrix(cbind(yr_bg$x,yr_bg$y))),yr_bg )
#add to overall dataset
if(y==1){env_ext<- yr_ext; bg_ext<- yr_bg}
else{
env_ext<- rbind(env_ext, yr_ext)
bg_ext<- rbind(bg_ext, yr_bg)
}
rm(yr_env)
gc() #garbage collector
}
##playing with NAs
env_NA<- env_ext[!complete.cases(env_ext), ]
NA_dup<- env_NA[!duplicated(env_NA[c('cell')]), ]
plot(fenno_layers,1)
points(NA_dup[4,5])
Fenno<- vect("data/Fenno.gpkg")
crs(Fenno)<- crs(fenno_layers)
plot(Fenno)
points(NA_dup[4,5], col="red")
head(NA_dup[4,5])
dim(NA_dup)
points(NA_dup[4:5], col="red")
plot(Fennp)
plot(Fenno)
points(NA_dup[,4:5], col="red")
plot(land_layers)
plot(fenno_layers)
fenno_elev<- rast("data/elev_Fenno_ll.tif")
fenno_coast<- rast("data/distance_to_coast_ll.tif")
fenno_water<- rast("data/perc_cover_freshwater_Fenno_ll.tif")
fenno_land<- rast("data/fenno_land_wupdate.tif")
par(mfrow=c(2,2))
plot(fenno_elev)
plot(fenno_land)
plot(fenno_water)
plot(fenno_coast)
ext(fenno_elev)
ext(fenno_coast)
fenno_elev
fenno_land
ext(fenno_land)<- ext(fenno_elev)
test_stack<- c(fenno_land, fenno_elev)
fenno_land
fenno_elev
fenno_land<- rast("data/fenno_land_wupdate.tif")
test_land<- crop(fenno_land, fenno_elev)
test_land
test_stack<- c(test_land, fenno_elev)
ext(test_land)<- ext(fenno_elev)
test_stack<- c(test_land, fenno_elev)
plot(test_stack)
rm(test_land)
rm(test_stack)
fenno_land<- crop(fenno_land, fenno_elev)
ext(fenno_land)<- ext(fenno_elev)
fenno_coast<- crop(fenno_coast, fenno_elev)
ext(fenno_coast)<- ext(fenno_elev)
fenno_water<- crop(fenno_water, fenno_elev)
ext(fenno_water)<- ext(fenno_elev)
land_layers<- c(fenno_elev, fenno_land, fenno_water, fenno_coast)
fenno_land
fenno_elev
fenno_coast
fenno_land<- rast("data/fenno_land_wupdate.tif")
fenno_water<- rast("data/perc_cover_freshwater_Fenno_ll.tif")
fenno_coast<- rast("data/distance_to_coast_ll.tif")
fenno_elev<- rast("data/elev_Fenno_ll.tif")
#concatenate land layers
#NB some extents vary slightly so need to standardise them
#make extents and dimensions match smallest, which is fenno_elev
fenno_land<- resample(fenno_land, fenno_elev)
fenno_coast<- resample(fenno_coast, fenno_elev)
fenno_water<- resample(fenno_water, fenno_elev)
land_layers<- c(fenno_elev, fenno_land, fenno_water, fenno_coast)
plot(land_layers)
names(land_layers)<- c("Elevation", "Land_cover","Perc_water", "Dist_coast")
terra::writeRaster(land_layers, "data/land_layers_fenno.tif", overwrite=T)
land_layers<- rast("data/land_layers_fenno.tif")
plot(land_layers)
install.packages("DescTools")
library(DescTools)
#most NAs are located near the coast, so want to fill in the NAs
env_ext_NA<- ImputeKnn(env_ext[!complete.cases(env_ext), ])
head(d.pizza)
#most NAs are located near the coast, so want to fill in the NAs
env_ext_NA<- ImputeKnn(env_ext[,-2])
rm(DescTools)
detach("package:DescTools", unload = TRUE)
?extract
?focal
#most NAs are located near the coast, so want to fill in the NAs
land_layers_focal<- focal(land_layers, 3, "mean", na.policy="only", na.rm=T)
plot(land_layers)
plot(land_layers_focal)
?spatsample
?spatSample
library(caret)
install.packages("caret")
pnt <- spatSample(rr,500,"random",as.df=T,xy=T)
set.seed(4)
f <- system.file("ex/elev.tif", package="terra")
r <- rast(f)
plot(r)
#create raster stack
rr <- c(r,r*2,r/2,log(r))
plot(rr)
pnt <- spatSample(rr,500,"random",as.df=T,xy=T)
class(pnt)
head(pnt)
pp <- preProcess(pnt[,-c(1:2)],method="bagImpute")
library(caret)
pp <- preProcess(pnt[,-c(1:2)],method="bagImpute")
new_pnt <- predict(pp,pnt[,-c(1:2)])
head(pp)
View(pnt)
View(bg_ext)
View(env_ext)
NA_impute <- preProcess(env_ext[,-c(1:5)],method="bagImpute")
new_pnt <- predict(NA_impute,pnt[,-c(1:5)])
new_pnt <- predict(NA_impute,env_ext[,-c(1:5)])
heaed(new_pnt)
head(new_pnt)
head(env_ext)
env_no_NA <- cbind(env_ext[,1:5],new_pnt)
##playing with NAs
env_NA<- env_no_NA[!complete.cases(env_no_NA), ]
View(env_NA)
#get rid of duplicates
env_ext_dup<- env_no_NA[!duplicated(env_no_NA[c('cell')]), ]
env_no_NA<- env_no_NA[complete.cases(env_no_NA),]
fenno_land
unique(values(fenno_land))
fenno_land<- rast("data/land_cover_Fenno_ll_combined.tif")
unique(values(fenno_land))
fenno_land<- rast("data/fenno_land_wupdate.tif")
unique(values(fenno_land))
fenno_water<- rast("data/perc_cover_freshwater_Fenno_ll.tif")
plot(fenno_water)
#update fenno_land with this waterbody info
#create a copy that has water being habitat type 8
fenno_w<- fenno_water
fenno_w[fenno_w>0]<- 8
plot(fenno_w)
fenno_w[fenno_w==0]<- NA
plot(fenno_w)
fenno_land<- rast("data/land_cover_Fenno_ll_combined.tif")
fenno_land_w<- merge(fenno_w, fenno_land)
unique(values(fenno_land_w))
?merge
unique(values(fenno_land_w))
unique(values(fenno_w))
unique(values(fenno_land))
fenno_land_w<- merge(fenno_land, fenno_w)
unique(values(fenno_land_w))
fenno_land_w<- merge(fenno_w, fenno_land, first=F)
unique(values(fenno_land_w))
?mask
fenno_land_w<- mosaic(fenno_w, fenno_land, fun="first")
unique(values(fenno_land_w))
unique(values(fenno_w))
unique(values(fenno_land))
fenno_land_w<- mosaic(fenno_w, fenno_land, fun="min")
unique(values(fenno_land_w))
fenno_land_w<- mosaic(fenno_w, fenno_land, fun="first")
unique(values(fenno_land_w))
fenno_land_w<- merge(fenno_w, fenno_land, first=T)
unique(values(fenno_land_w))
fenno_land_w<- merge(fenno_w, fenno_land, first=T, na.rm=F)
unique(values(fenno_land_w))
plot(fenno_land_w)
fenno_w
fenno_land
fenno_w<- resample(fenno_w, fenno_land)
fenno_w
fenno_land_w<- merge(fenno_w, fenno_land, first=T)
unique(values(fenno_land_w))
terra::plot(fenno_land_w, col=c("darkgreen", "lightgreen",
"darkviolet","darkolivegreen3",
"darkseagreen", "darkgoldenrod",
"burlywood", "deepskyblue3",
"darkslategray1", "brown1"))
terra::writeRaster(fenno_land_w, "data/fenno_land_wupdate.tif")
terra::writeRaster(fenno_land_w, "data/fenno_land_wupdate.tif", overwrite=T)
fenno_land<- rast("data/fenno_land_wupdate.tif")
#concatenate land layers
#NB some extents vary slightly so need to standardise them
#make extents and dimensions match smallest, which is fenno_elev
fenno_land<- resample(fenno_land, fenno_elev)
fenno_coast<- resample(fenno_coast, fenno_elev)
fenno_water<- resample(fenno_water, fenno_elev)
land_layers<- c(fenno_elev, fenno_land, fenno_water, fenno_coast)
names(land_layers)<- c("Elevation", "Land_cover","Perc_water", "Dist_coast")
terra::writeRaster(land_layers, "data/land_layers_fenno.tif", overwrite=T)
land_layers<- rast("data/land_layers_fenno.tif")
years<- sort(unique(xy_2000s$year))
#now i need to match the presence points (per year) to the environment of that year
#all variables need to be in a single stack so that you can pass it to extract()
env_ext<-c()
bg_ext<- c()
for(y in 1:length(years)){
print(years[y])
yr_dat<- xy_2000s[xy_2000s$year==years[y],] #get the position data
#turn it into a terra::vect
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(land_layers))
#read in that year's environmental/habitat data
yr_env<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
#match coordinates with env data
yr_ext<- terra::extract(yr_env, yr_vect, xy=T, cells=T)[,c(10:12, 2:9)]
#yr_ext<- yr_ext[complete.cases(yr_ext), ]
yr_ext<- cbind(occ=rep(1,nrow(yr_ext)), year=rep(years[y],nrow(yr_ext)), yr_ext)
#get pseudo-absence points
yr_bg<- sdm::background(yr_env, 100, "gRandom" )#[,-c(1:2)]
yr_bg<- cbind(occ=rep(0,nrow(yr_bg)),year=rep(years[y],nrow(yr_bg)),
cell=cellFromXY(yr_env, as.matrix(cbind(yr_bg$x,yr_bg$y))),yr_bg )
#add to overall dataset
if(y==1){env_ext<- yr_ext; bg_ext<- yr_bg}
else{
env_ext<- rbind(env_ext, yr_ext)
bg_ext<- rbind(bg_ext, yr_bg)
}
rm(yr_env)
gc() #garbage collector
}
write.table(env_ext, "data/sdm_fenno/dynamic_pres_dataset.txt", quote=F, row.names=F)
write.table(bg_ext, "data/sdm_fenno/dynamic_bg_dataset.txt", quote=F, row.names=F)
NA_impute <- preProcess(env_ext[,-c(1:5)],method="bagImpute")
new_pnt <- predict(NA_impute,env_ext[,-c(1:5)])
env_no_NA <- cbind(env_ext[,1:5],new_pnt)
env_no_NA<- env_no_NA[complete.cases(env_no_NA),]
View(env_no_NA)
View(env_ext)
unique(values(land_layers$Land_cover))
land_layers<- rast("data/land_layers_fenno.tif")
unique(values(land_layers$Land_cover))
y=1
old<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
unieuq(values(old$Land_cover))
unique(values(old$Land_cover))
old$Land_cover<- land_layers$Land_cover
unique(values(old$Land_cover))
years
for(y in 1:length(years)){
old<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
old$Land_cover<- land_layers$Land_cover
writeRaster(fenno_layers, paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""), overwrite=T)
}
plot(fenno_layers)
fenno_lkayers
fenno_layers
y
y=1
old<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
plot(old)
#make era5 match CHELSA and create layers for Fenno
#need Fenno outline
crs(Fenno)<- crs(fenno_coast)
years<- seq(2000,2023,1)
land_layers<- rast("data/land_layers_fenno.tif")
for(y in 1:length(years)){
print(years[y])
if(years[y]<=2018){ #for the first 19 years, use CHELSA
env_y<- rast(paste("data/CHELSA/",years[y], "_layers.tif", sep=""))
env_sub<- subset(env_y, c(1,2,8,10))/10-273.15
# original values from CHELSA were K/10
#these values are stored *10 for memory reasons
env_sub[[2]]<- env_sub[[2]]+273.15 #this is a range, so didn't need to be converted from K
}
else{ #otherwise use era5
env_y<- rast(paste("data/era5/biovars_",years[y], ".tif", sep=""))
env_sub<- subset(env_y,c(1,2,8,10))-273.15 #convert from K to C
env_sub[[2]]<- env_sub[[2]]+273.15 #this is a range, so didn't need to be converted from K
}
#make sure env layers match land layers
env_resam<- terra::resample(env_sub, fenno_coast)
crs(env_resam)<- crs(fenno_coast)
env_crop<- mask(env_resam, Fenno)
#create stack
fenno_layers<- c(env_crop, land_layers)
names(fenno_layers)<- c("Temp", "Diurnal_range", "Temp_wet", "Temp_warm", "Elevation", "Land_cover",
"Perc_water", "Dist_coast")
#write file
writeRaster(fenno_layers, paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""), overwrite=T)
#free up memory
rm(env_y)
rm(env_sub)
rm(env_resam)
rm(env_crop)
gc()
}
y
y=1
old<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
unique(values(old$Land_cover))
rm(old
)
rm(pp)
rm(pnt)
rm(rr)
rm(r)
gc()
#now i need to match the presence points (per year) to the environment of that year
#all variables need to be in a single stack so that you can pass it to extract()
env_ext<-c()
bg_ext<- c()
for(y in 1:length(years)){
print(years[y])
yr_dat<- xy_2000s[xy_2000s$year==years[y],] #get the position data
#turn it into a terra::vect
yr_vect<- vect(yr_dat[,1:2], geom=c("longitude", "latitude"), crs=crs(land_layers))
#read in that year's environmental/habitat data
yr_env<- rast(paste("data/sdm_fenno/", years[y], "_layers.tif", sep=""))
#match coordinates with env data
yr_ext<- terra::extract(yr_env, yr_vect, xy=T, cells=T)[,c(10:12, 2:9)]
#yr_ext<- yr_ext[complete.cases(yr_ext), ]
yr_ext<- cbind(occ=rep(1,nrow(yr_ext)), year=rep(years[y],nrow(yr_ext)), yr_ext)
#get pseudo-absence points
yr_bg<- sdm::background(yr_env, 100, "gRandom" )#[,-c(1:2)]
yr_bg<- cbind(occ=rep(0,nrow(yr_bg)),year=rep(years[y],nrow(yr_bg)),
cell=cellFromXY(yr_env, as.matrix(cbind(yr_bg$x,yr_bg$y))),yr_bg )
#add to overall dataset
if(y==1){env_ext<- yr_ext; bg_ext<- yr_bg}
else{
env_ext<- rbind(env_ext, yr_ext)
bg_ext<- rbind(bg_ext, yr_bg)
}
rm(yr_env)
gc() #garbage collector
}
?predict
write.table(env_ext, "data/sdm_fenno/dynamic_pres_dataset.txt", quote=F, row.names=F)
write.table(bg_ext, "data/sdm_fenno/dynamic_bg_dataset.txt", quote=F, row.names=F)
NA_impute <- caret::preProcess(env_ext[,-c(1:5)],method="bagImpute")
new_pnt <- sdm::predict(NA_impute,env_ext[,-c(1:5)])
new_pnt <- caret::predict(NA_impute,env_ext[,-c(1:5)])
new_pnt <- terra::predict(NA_impute,env_ext[,-c(1:5)])
env_no_NA <- cbind(env_ext[,1:5],new_pnt)
env_no_NA<- env_no_NA[complete.cases(env_no_NA),]
count(is.na(env_ext$Land_cover))
length(env_ext$Land_cover[is.na(env_ext$Land_cover)])
citation(caret])
citation(caret)
citation("caret")
#get rid of duplicates
env_ext_dup<- env_no_NA[!duplicated(env_no_NA[c('cell')]), ]
# Remove adjacent cells of presence/background data:
occ<- env_ext_dup[,c(4,5,2, 6:13)]
colnames(occ)<- c("x","y", "year", "Temp","Diurnal_range","Temp_wet","Temp_warm","Elevation",
"Land_cover","Perc_water","Dist_coast")
variablenames<- colnames(occ)[-(1:3)]
autocorrelation <- spatiotemp_autocorr(occ,
varname = variablenames,
plot = TRUE,
temporal.level = c("year"))
autocorrelation
#combine presence and pseudo-absence
all_data<- rbind(env_ext_dup, bg_ext)
##split for train and test
train_i <- sample(seq_len(nrow(all_data)), size=round(0.7*nrow(all_data)))
# Then, we can subset the training and testing data
isch_train <- all_data[train_i,]
isch_test <- all_data[-train_i,]
write.table(isch_train, "data/sdm_fenno/dynamic_train.txt", quote=F, row.names=F)
write.table(isch_test, "data/sdm_fenno/dynamic_test.txt", quote=F, row.names=F)
